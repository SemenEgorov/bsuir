## Лабораторная работа №1
Вариант 24

Постановка задачи: Двунаправленный список. Вставка элемента в список. Удаление
элемента из списка. Сортировка списка. Поиск элемента в списке.
Объединение двух списков. Пересечение двух списков.
## Определения:
<details>
  <summary></summary>

* __Двусвязный (двунаправленный) список__ — это разновидность связного списка, при которой переход по элементам возможен в обоих направлениях (как вперед, так и назад), в отличие от односвязного (однонаправленного) списка.
* __Ссылка__. В каждой ссылке связного списка могут храниться данные, называемые элементом ```(item)```.
* __Следующая ссылка__. В каждой ссылке связного списка содержится ссылка на следующую ссылку ```(next)```.
* __Предыдущая ссылка__. В каждой ссылке связного списка содержится ссылка на предыдущую ссылку ```(prev)```.
* __Связный список__ содержит ссылку (указатель) на первую ссылку ```(first)``` и на последнюю ссылку ```(last)```.

![](https://github.com/iit-22170x/RPIIS/blob/8b8627766725bc2b92da07f5f8300ba1446d0212/sem2/img/linkedlist.jpg)

</details>

## Описание алгоритма:

<details>
  <summary></summary>

При инициализации объекта класса cоздаётся пустой список. ```(first)``` и ```(last)``` ни указывают ни на что.

* __Вставка элемента в список:__

Инициализируются новая ссылка, в которую записывается переданный элемент. 
Каждая предыдущая и следующая ссылки, соседние новой ссылке, изменяются так, чтобы новая ссылка заняла свою порядковую позицию.
Если список был пустой, то при добавлении новой ссылки указатели ```(first)``` и ```(last)``` устанавливаются на новую ссылку. 
С добавлением в конец списка новой ссылки указатель ```(last)``` устанавливается на новую ссылку.  
С добавлением в начало списка новой ссылки указатель ```(first)``` устанавливается на новую ссылку.

```cpp
push_back(const Type&)
``` 
Добавляет элемент в конец списка.

```cpp
push_front(const Type&)
```
Добавляет элемент в начало списка.

```cpp
add(const Type&, int)
```
Добавляет элемент в список на определённую позицию.

```cpp
add(const Type[], int, int)
```
Добавляет массив, известной длины, на определённую позицию в список.

```cpp
add(const DoublyLinkedList<Type>&, int)
```
Добавляет элементы другого списка на определённую позицию списка.

```cpp
add(const DoublyLinkedList<Type>&)
```
Добавляет элементы другого списка в конец списка.

* __Удаление элемента из списка:__

При удалении элемента из списка, следующие и предыдущие ссылки соседних элементов, изменяются так, чтобы указывать друг на друга (*сшиваются*).
При удалении первого элемента указатель ```(first)``` устанавливается на новый первый элемент.
При удалении последнего элемента указатель ```(last)``` устанавливается на новый последний элемент.

```cpp
erase(int);
```
Удаляет элемент по известной позиции.

* __Сортировка списка:__

Сортировка списка происходит по алгоритму сортировки *пузырьком*.

```cpp
sort()
```
Сортировка списка по возрастанию.

```cpp
sort_r()
```
Сортировка списка по убыванию.

* __Поиск элемента в списке:__

Элемент ищется с начала/конца списка до тех пор, пока не будет найдено первое/последнее вхождение элемента.
Если же элемента нет в списке, то возвращаемым значением будет невалидная позицая элемента (-1).

```cpp
findElement_beg(Type)
```
Поиск идёт с начала списка.

```cpp
findElement_end(Type)
```
Поиск идёт с конца списка.

* __Объединение списков:__

Объединение списков происходит при помощи <code>findElement_beg</code>. Если элемент из первого списка был найден во втором списке, то заново он добавлен не будет.
Если элемент из первого списка не был найден во втором списке, то он будет добавлен в первый список.

```cpp
combining(const DoublyLinkedList<Type>&)
```
Объединение первого списка со вторым (передаваемым). Изменён будет первый список.

* __Пересечение списков:__

Пересечение списков происходит при помощи <code>findElement_beg</code>. Если элемент из первого списка не был найден во втором списке, то он удаляется.
Если элемент из первого списка был найден во втором списке, то он удалён не будет.

```cpp
intersection(const DoublyLinkedList<Type>&)
```
Пересечение первого списка со вторым (передаваемым). Изменён будет первый список.

</details>

## Пример работы:
<details>
  <summary></summary>

* __Первый тест__

В первом тесте проверяется работоспособность методов ```combining``` и ```intersection```. Инициализируются 3 списка.
Задаются первые 2 списка (третий приравнивается ко второму), после чего производится операция объединения первого списка со вторым. Результат объединения выводится на экран.
Затем происходит операция пересечения второго списка с первым. Результат выводится на эран. Ожидается, что результатом операции пересечения будет изначально заданный второй список. 
Поэтому результат операции пересечения сравнивается с третьим списком.

![](https://github.com/iit-22170x/RPIIS/blob/8b8627766725bc2b92da07f5f8300ba1446d0212/sem2/img/test1.png)


* __Второй тест__

Во втором тесте проверяется работоспособность методов ```sort``` и ```sort_r```. Инициализируются 3 списка. 
Задаётся первый список, после чего производится операция сортировки по возрастанию первого списка, результат выводится на экран и приравнивается второму списку.
Затем происходит операция сортировки по убыванию второго списка, результат выводится на экран и приравнивается третьему списку.
Ожидается что второй список будет равен отсортированному по возрастанию третьему.

![](https://github.com/iit-22170x/RPIIS/blob/8b8627766725bc2b92da07f5f8300ba1446d0212/sem2/img/test2.png)


* __Третий тест__
В третьем тесте проверяется работоспособность методов ```erase``` и ```findElement_beg```. Инициализируются 1 список. 
Задаётся первый список, после чего вводится число,которое должно быть полностью удалено из списка. Элемент удаляется до тех пор, пока метод
```findElement_beg``` не вернёт невалидную позицию. Затем циклически проверяется "*наличие*" данного элемента в списке.

![](https://github.com/iit-22170x/RPIIS/blob/8b8627766725bc2b92da07f5f8300ba1446d0212/sem2/img/test3.png)


* __Четвёртый тест__

В четвёртом тесте проверяется работоспособность метода ```push_back```, а также общая работоспособность списка (проверка связей).
Инициализируется список, каждый элемент которого - список. Списки заполняются и добавляются в общий список.
После чего списки сортируются в порядке убывания их длин. Результат выводится на экран. После производится циклическая проверка. 

![](https://github.com/iit-22170x/RPIIS/blob/8b8627766725bc2b92da07f5f8300ba1446d0212/sem2/img/test4.png)



* __Пятый тест__

В пятом тесте проверяется работоспособность метода ```add```. Инициализируется массив длины 5 и 2 списка. 
Задаётся массив, после задаётся второй список. Затем в первый список добаляется сначала массив, а потом второй список в конец. Производится циклическая проверка на добавление всех элементов.


![](https://github.com/iit-22170x/RPIIS/blob/8b8627766725bc2b92da07f5f8300ba1446d0212/sem2/img/test5.png)



</details>

## Вывод
<details>
  <summary></summary>

Лабораторная работа познакомила меня с такой структурой данных как двусязный список. Я реализовал двунапправленный списокб методы добавления, удаления, поиска, пересечения, объединения, сортировки, а также ознакомился с <code>template</code> и с классами. 

  </details>

## Источники

<details>
  <summary></summary>

https://medium.com/nuances-of-programming/структуры-данных-и-алгоритмы-двусвязный-двунаправленный-список-8d2bcb42da49

https://prog-cpp.ru/data-dls/

</details>
