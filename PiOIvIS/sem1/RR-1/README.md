## Расчётная работа N1
Вариант 5.29, способ выражения графа: списки смежности.

Постановка задачи: найти дерево кратчайших путей.
## Определения:
<details>
  <summary></summary>

* __Граф__ - это топологичекая модель, которая состоит из множества вершин и множества соединяющих их рёбер. При этом значение имеет только сам факт, какая вершина с какой соединена.
* __Вершина__ - точка в графе, отдельный объект, для топологической модели графа не имеет значения координата вершины, её расположение, цвет, вкус, размер; однако при решении некоторых задачах вершины могут раскрашиваться в разные цвета или сохранять числовые значения.
* __Ребро__ - неупорядоченная пара двух вершин, которые связаны друг с другом. Эти вершины называются концевыми точками или концами ребра. При этом важен сам факт наличия связи, каким именно образом осуществляется эта связь и по какой дороге - не имеет значения.
* __Невзвешенный граф__ - граф, ребра которого не имеют веса.
* __Потомок вершины__ – это вершина, в которую ведет путь из данной вершины.
* __Ориентированный граф__ или __Орграф__ - граф, в котором рёбра имеют направления.
* __Граф__, ни одному ребру которого не присвоено направление, называется неориентированным графом или неорграфом.
* __Смежность вершин__ - две вершины называются смежными, если они инцидентны одному ребру.
* __Изолированная вершина__ - вершина, не соединённая с другими вершинами ни одним ребром.
* __Путь__ или __Маршрут__ - это последовательность смежных рёбер. Обычно путь задаётся перечислением вершин, по которым он пролегает.

</details>

## Описание алгоритма:

<details>
  <summary></summary>


На вход программе подаётся граф, в виде списка смежности (вершины в нём представлены в виде порядковых номеров, начиная от 0). Программа использует алгоритм поиска в ширину (__Breadth-first-search__). Поиск в ширину подразумевает поуровневое исследование графа: вначале посещается корень – произвольно выбранная вершина, затем – все потомки данной вершины, после этого посещаются потомки потомков и т.д. Вершины просматриваются в порядке возрастания их расстояния от корня.
![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/50cde188f7b54a887e482b9447dc7abb.gif)

Основную идею алгоритма можно понимать как процесс «поджигания» графа: на нулевом шаге мы поджигаем корневую вершину, а на каждом следующем шаге огонь с каждой уже горящей вершины перекидывается на всех её соседей, в конечном счете поджигая весь граф.
 Пошаговая работа алгоритма:
 * Выбираем вершину для которой хотим найти дерево кратчайших путей.
 * Присвоим каждой вершине, кроме выбранной, метку непосещённой.
 * Так же для каждой, кроме корневой, вершины запишем в массив путей номер несуществующей вершины. Корневой вершине присвоим в путь свой же номер. 
(В дальнейшем будет использоваться для поиска изолированной вершины, в которую мы никак не сможем попасть из корня)
* Для текущей вершины рассмотрим всех её не посещенных соседей, запишем для них номер вершины (предка), из которого мы попали в данные вершины и отметим их как посещённые. Добавим все непосещённые вершины, смежные нашим в "_очередь_".
* В порядке "_очереди_" будем повторять предыдущий пункт для каждой вершины из "_очереди_" до тех пор пока "_очередь_" не станет пуста.

В результате работы алгоритма формируется массив содержащий для каждой вершины номер её соседа, имеющего кратчайший путь до корневой вершины.

Выведем получившийся результат рекурсивно. Будем выводить номера вершин (взятые элементы по индексу из нашего массива) до тех пор, пока индекс взятой вершины не будет соответсвовать элементу по этому индексу (так мы дойдём до корневой вершины, т.к только её индекс соответсвует элементу по этому индексу).

</details>

## Пример работы:
<details>
  <summary></summary>

* __Первый тест__

![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph1.png)

![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph1tree.png)![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph1treeanswer.png)

![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph1test.jpg)

В данном примере строится дерево кратчайших путей (в виде списков смежности), 0 - корневая вершина.

Рассмотрим нахождение кратчайших путей, взяв за корневую вершину 0.

Получаем что кратчайший путь из 0 в 1 - ``` 0 1 ```;

Получаем что кратчайший путь из 0 в 2 - ``` 0 1 2```;

Получаем что кратчайший путь из 0 в 3 - ``` 0 1 3```;

Вершина 4 - изолированная, поэтому для неё путь получить не удастся.

* __Второй тест__

![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph2.png)

![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph2tree.png)![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph2treeanswer.png)

![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph2test.jpg)

В данном примере строится дерево кратчайших путей (в виде списков смежности), 4 - корневая вершина.

Рассмотрим нахождение кратчайших путей, взяв за корневую вершину 4.

Получаем что кратчайший путь из 4 в 0 - ``` 4 1 0```;

Получаем что кратчайший путь из 4 в 1 - ``` 4 1```;

Получаем что кратчайший путь из 4 в 2 - ``` 4 2```;

Получаем что кратчайший путь из 4 в 3 - ``` 4 3```;
* __Третий тест__

![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph3.png)

![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph3tree.png)![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph3treeanswer.png)

![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph31test.jpg)

![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph32test.jpg)

![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph33test.jpg)

В данном примере строится дерево кратчайших путей (в виде списков смежности), 0 - корневая вершина.

Данный граф интересен для нас тем, что, чем дальше выбранная вершина от 0, тем меньше существует вершин, в которые можно попасть из выбранной вершины.

Из вершины 0 мы можем попасть во все вершины данного графа;

Из вершины 3 мы можем попасть только в вершины 4, 5, 6, 7, 8;

Из вершины 6 мы можем только в вершину 8;

Из вершины 8 мы не можем попасть никуда;

* __Четвёртый тест__

![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph4.png)

![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph4tree.png)![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph4treeanswer.png)

![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph4test.jpg)

В данном примере строится дерево кратчайших путей (в виде списков смежности), 3 - корневая вершина.

У данного графа каждая вершина связана, с каждой. Для каждой вершины кратчайший путь до другой вершины будет состоять всего из одного шага.

Рассмотрим нахождение кратчайших путей, взяв за корневую вершину 3.

Получаем что кратчайший путь из 3 в 0 - ``` 3 0 ```;

Получаем что кратчайший путь из 3 в 1 - ``` 3 1 ```;

Получаем что кратчайший путь из 3 в 2 - ``` 3 2```;

Получаем что кратчайший путь из 3 в 4 - ``` 3 4 ```;

Получаем что кратчайший путь из 3 в 5 - ``` 3 5```;

Получаем что кратчайший путь из 3 в 6 - ``` 3 6 ```;

Получаем что кратчайший путь из 3 в 7 - ``` 3 7```;

Получаем что кратчайший путь из 3 в 8 - ``` 3 8```;

* __Пятый тест__

![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph52.png)

![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph5tree.png)![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph5treeanswer.png)

![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph5test1.jpg)![](https://github.com/SemenEgorov/bsuir/blob/main/PiOIvIS/sem1/RR-1/RR-1graphs/graph-images/graph5test2.jpg)

В данном примере строится дерево кратчайших путей (в виде списков смежности), 2 - корневая вершина.

У данного графа вершины 4 и 7 связаны только с вершиной 2. Кратчайшими путями из вершин 4 и 7 до других вершин будут являться те же кратчайшие пути, что и из вершины 2, за исключением того, что сначала надо будет попасть в вершину 2.
Рассмотрим нахождение кратчайших путей, взяв за корневую вершину 3.

Получаем что кратчайший путь из 7 в 0 - ``` 7 2 0```;

Получаем что кратчайший путь из 7 в 1 - ``` 7 2 0 1```;

Получаем что кратчайший путь из 7 в 2 - ``` 7 2```;

Получаем что кратчайший путь из 7 в 3 - ``` 7 2 0 3```;

Получаем что кратчайший путь из 7 в 4 - ``` 7 2 4```;

Получаем что кратчайший путь из 7 в 5 - ``` 7 2 5```;

Получаем что кратчайший путь из 7 в 6 - ``` 7 2 0 1 6```;

Получаем что кратчайший путь из 7 в 8 - ``` 7 2 0 3 8```;

Получаем что кратчайший путь из 7 в 9 - ``` 7 2 5 9```;

Получаем что кратчайший путь из 7 в 10 - ``` 7 2 5 9 10```;

</details>

## Вывод
<details>
  <summary></summary>
Расчётная работа познакомила меня с понятием  графа и некоторыми ему прилегающими, его представлением в памяти компьютера. Я ознакомился с алгоритмом поиска в ширину, работой с файлами. Работой с классом <code> queue </code> и его методами. 

  </details>

## Источники

<details>
  <summary></summary>

https://habr.com/ru/company/otus/blog/568026/
https://habr.com/ru/company/otus/blog/675730/
https://translated.turbopages.org/proxy_u/en-ru.ru.7b38c210-638a1375-905971c7-74722d776562/https/en.wikipedia.org/wiki/Dijkstra%27_algorithm
https://habr.com/ru/post/661577/
https://ru.algorithmica.org/cs/shortest-paths/bfs/
https://ru.wikipedia.org/wiki/Поиск_в_ширину
https://learn.microsoft.com/ru-ru/cpp/standard-library/cpp-standard-library-header-files?view=msvc-170
https://translated.turbopages.org/proxy_u/en-ru.ru.dc9c7f8d-638a57ac-b6fc90d4-74722d776562/https/en.wikipedia.org/wiki/Shortest-path_tree

</details>